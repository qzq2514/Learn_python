#字符	  ASCII	     Unicode	             UTF-8
#A	    01000001	00000000 01000001	   01000001
#中	       x	    01001110 00101101      11100100 10111000 10101101

str="aabccd";            #string字符串类型是不可变类型，所以这里即便调用replace方法，但是其实并没有改变该自身的内容
str2=str.replace('a','A');#相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。
print(str);
print(str2);

print(ord("A"));           ##ord函数将字符转化为对应的整数表示
print(ord('中'));

print(chr(20013));         ##ord函数将整数表示转化为对应的字符
print(chr(66));


print('\u4e2d\u6587');    #知道字符的整数编码，还可以用十六进制这么写 #25991=\u6587


#一般的字符串，如'ABC'在内存中以Unicode码表示。一个字符对应若干个字节。但是在网络上传播，就需要将str变为
#以字节为单位的bytes
x='ABC';
print(x);
#Python对bytes类型的数据用带b前缀的单引号或双引号表示：
x=b'ABC';       #这里变为含有中文字符就不行,x='中BC'报错
print(x);
#要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节

#encode对字符串进行编码,得到的结果都是bytes型，形如b''
print('ABC'.encode('ascii'));
print('中文'.encode('utf-8'));        #带有中文的不能用ascii编码，超出ascii范围

#从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法进行解码
print(b'ABC'.decode('ascii'));
print(b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8'));    #这里不能写成b'中文'.decode('utf-8')



print(len('fsdA中文BC'));  #len函数求字符串长度，即字符个数
print(len(b'ABC'));
print(len("中文".encode('utf-8')));     #对于bytes型，len求的是字节数目,这里一个中文字符占三个字节



#格式化占位符
#   %d	整数
#   %f	浮点数
#   %s	字符串
#   %x	十六进制整数
print("我年龄是: %d,我喜欢的颜色是:%s" % (21,"黑色"));       #就用类似的方法进行格式化，用%将格式模板和填充内容隔开
print("我的名字是: %s" % "祁忠琪");    #填充内容只有一个，不需要用括号括起来
print('%4d-%020d' % (3, 1));            #数字补零占位,格式:%[a][b]d 其中a是填充的字符，不写就表示用空格填充,b表示填充+整数的总长度

#不确定用%d,%s,%x,%f等中的哪一个进行填充模板，那么都可以用%s，并且这里看到同样可以进行占位补空格
#注意这里用%S占位整数后，那么只能用空格补位，所以这里即便写成%08s仍然不会输出"00000012",而是输出"      12"
print('%s-%8s' % (True, 12));     
print("比例:%d%%" % 80) ;#用%%来表示一个%